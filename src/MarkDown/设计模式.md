# 简介
> 设计模式是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

# 设计模式的六大原则

## 单一职责原则（SRP）：
就一个类而言，应该仅有一个引起它变化的原因

## 开闭原则（OCP）：
实体（类、模块、函数）对扩展开放，对修改关闭
保证项目的稳定

## 里式替换原则（LSP）：
父类可以被子类无缝替换，且原有功能不受影响

## 迪米特法则，最少知道原则（LOD）
降低类之间的偶合，尽量减少对其他类的了解。

例子，收费处不直接对处方明细类直接调用，而是通过处方类再去获取处方明细类

## 依赖倒装原则（DIP）：
程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

## 接口隔离原则（ISP）：
一个接口不要有过多的方法，尽量拆分成多个更小更具体的接口

# 模式分类

所有模式可以根据其意图或目的来分成三种主要的模式类别：

- **创建型模式** 提供创建对象的机制， 增加已有代码的灵活性和可复用性。

- **结构型模式** 介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

- **行为模式** 负责对象间的高效沟通和职责委派。

# 模式讲解
> 下面的模式讲解为本人自己对模式的理解，简化成自己能思考认知的话。
----
## 创造型
### 单例模式
保证一个类只有一次实现，私有化构造方法，然后在初始化的时候加载（饿汉模式）

### 工厂模式
只是为了处理开闭原则
通过工厂类来创建对象，不过需要自己选择哪个工厂类

### 抽象工厂模式
不通过new工厂的方式生成接口，而是由一个超级工厂类来通过配置获取对应工厂类，再有工厂类实现具体功能

### 原型模式
（继承Icloneanle）拥有一个clone方法，能够创建初始化信息

### 建造者模式
将类的实现拆分成多个组件方法，然后复用这些组件方法实现多个特定的方法再拿来调用

### 简单工厂（特别的工厂模式）
在获取需要的实体类时，不直接new，而是通过一个工厂类，不对外暴露具体的创建逻辑
而是通过一个公共的接口来创建。

## 结构型模式
### 适配器模式
为解决接口能给其他环境复用，但是接口与环境存在差异的情况。

### 装饰器模式
动态的添加更多功能的一种方法
创建实现A接口的实体类，然后创建实现A接口的抽象装饰类
再创建实现抽象装饰类的实体装饰类
在实现的时候通过传入获取到抽象类实现的功能。
重写父类抽象方法，从而添加新的功能，并基础父类的基础方法

### 代理模式
代理类和动作类继承同一接口，代理类内部有动作类，代理类通过动作类来实现接口

### 组合模式
类里有一个List型的自身类属性，能存储多个自身类，并有Add和remove来个方法来操作

### 桥接模式
主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
将抽象类与它的实现分离，使他们可以独立的变化。
不直接继承方法接口，而是将方法接口传入到抽象接口里面，抽象接口再实现方法接口，使得抽象类的方法可以由传入的接口方法来实现

### 外观模式
将方法和方法定义到不同的类中，实现功能的时候一个个调用，而不是把所有方法写在一个实现上

### 享元模式
在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
给定一个工厂用来生成实体，并将生成的实体添加到list里，如果实体存在就不再生成

## 行为型

### 策略模式（行为型）
策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法

### 模板方法
就是通过抽象类来实现一些固定不变的方法，然后子类继承就自带这些方法了。

### 观察者模式
将方法注册到调用方法里，那么调用方法被调用的时候同时激活被注册的方法

### 状态模式
当一个类的内部状态改变时会影响其行为，使这个对象看起来像是改变了其类。
状态类内部有个Current状态，调用类调用状态类时执行Current类的动作方法，动作方法根据其内部逻辑变化状态Current，从而实现状态动作的变更。

### 备忘录模式
就是有个memo类存储类之前的状态

### 迭代器模式
就是foreach循环，继承Ienumerable，使用movenext实现

### 命令模式
方法被添加到命令类的list里，不立即执行，等到使用order类的excute执行方法后，统一执行

### 职责链模式
主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。
多个职责类实现职责接口，实现行为方法和设置下一个职责的方法。
行为方法在无法处理方法时调用下一职责继续调用行为方法，直到处理

### 中介者模式
当两个类之前有很多交互时，可以添加一个中间类来实现两个类的交互事件，而不是直接在两个类里加。

### 解释器模式
解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

### 访问者模式
访问者类通过继承统一接口实现一个方法，这个方法需要传入一个接口方法，这个接口方法被多个方法继承，于是在使用的时候可以通过for循环实例化访问者类和具体实现方法类

# 文章参考
设计模式目录 https://refactoringguru.cn/design-patterns/catalog
书籍：《大话设计模式》